\chapter{The finite element method}
\label{sec:fem}

This chapter discusses the well known and widely used method for solving partial differential equations, the finite element method (FEM).
To avoid building and adding another library to the already vast ecosystem of available FEM software, we use the multi-physics FEM library, \oomph.
From the website, \oomph is:
\begin{quote}
	an object-oriented, open-source finite-element library for the simulation of multi-physics problems. \cite{oomph}
\end{quote}
There are several high level features of any general finite element procedure that will be addressed below.
Discussing these features in generality allows 
In addition to this, an overview of specific implementation details and features available in \oomph will also be covered.




% -----------------------------------------------------------

\section{Preliminaries}

We begin this chapter by discussing the necessary mathematical background for the finite element method.

Let us first define a problem in our context of interest.
A problem $(P)$ is one or more differential equations, together with appropriate boundary or initial conditions such that 

\iffalse WHAT DO WE NEED TO INCLUDE?

* Sobolev spaces
* Hilbert spaces 
* Banach spaces
* Norms/inner products

\fi



\subsection{Function spaces}
The test functions used in the upcoming weak formulation are members of a Sobolev space.
These function spaces are used to weight the residual of equation, 

The space of functions
\begin{align}
	H^1(\Omega) = \left\{ v | v \in L^2(\Omega), \, \nabla v \in (L^2(\Omega))^n \right\},
\end{align}
consists of those functions that are square-integrable and have a square-integrable derivative.



% -----------------------------------------------------------

\section{Nodes, elements, and meshes}

The main components of a finite element procedure are the nodes, the elements, and the mesh.
A mesh is a collection of elements; an element is a collection of nodes.

Each node contains data about its location within 

The elements are the 

What is the order of the element?

How do we get from global to local coordinates?
We need the mapping
And with that we need the Jacobian of the mapping
(we have two change of coordinates: Cartesian -> Cylindrical -> Local
And so we have two Jacobian mappings)

On the elements we have defined basis functions.
These represent the function 

Together with the elements, other fundamental pieces of the FEM are the nodes and the mesh.
Every element consists of multiple nodal points, each of which holds data required for solving the problem.
For example, nodes contain the global coordinate of their position within the mesh

A mesh is a collection of elements


There is one more detail of the hierarchy of entities for \oomph.
A \texttt{Problem} object contains details of a specific implementation for a problem, one of whose components is a mesh.
A \texttt{Node} objects contains multiple \texttt{Data} objects, holding the any or more of the data mentioned above.
This is simply an implementation detail, but an important one nonetheless. 


One of the fortunate things about the FEM is the discrete entities that are involved.
This lends itself to object-oriented programming (OOP) design principles particularly well.
Such a design strategy involves the definition of classes, and their instantiation as objects.
Furthermore, classes may be extended using inheritance, allowing for highly abstracted and generic classes, and on the other end, highly specific classes.
This works to both developers and users of the library advantage.
Developers are able to work independently of each other, knowing only how their respective objects should interact.
Users are able to extend previous work to suit their own needs.
Further discussion of OOP design principles is irrelevant and outside of the scope of this project.





\subsection{The Galerkin method}

In the Galerkin method, the test functions are the element basis functions.





% -----------------------------------------------------------

\section{Weak formulation}

The classical or strong formulation of a differential equation is a solution $u_N$ satisfying the PDE and boundary condition at every point in the domain.


The weak form of a differential equation is a relaxation of the conditions for the existence of a solution to the differential equation.

A weak solution $u_N$ satisfies the essential (Dirichlet) boundary condition and that the weighted residual vanishes for any test function that is 0 on the essential boundary.

Instead, upon multiplying by a test function and integrating over the domain, we instead require that the equation is satisfied for all test functions from an appropriate space of test functions.


A sufficiently smooth solution satisfying the weak form will also satisfies the stong form.
Therefore the two statements of the problem are equivalent, given the smoothness requirements of the classical formulation.


Given a test function $v$ from some function space $V$, we multiply our equation by $v$ and integrate over the domain.

The smoothness requirements for the strong form 



We will now derive the weak form of the CSLP equation, \eqref{eqn:cslp}.
Our first step is to multiply by a test function $v\in V$ and integrate over the domain $\Omega$.
\begin{align}
	-\int_\Omega \left(\nabla^2 u_N + \left[ (1+i\alpha)k^2-\frac{N^2}{r^2}\right]u_N \right) v = 0.
\end{align}
Using the property of the gradient operator,
\begin{align}
	\nabla \cdot ( v \nabla u) = v \nabla^2 u + \nabla u \cdot \nabla v,
\end{align}
we arrive at
\begin{align}
	\int_\Omega \nabla u_N \cdot \nabla v 
  - \int_\Omega \nabla \cdot (v \nabla u ) 
  - (1+i\alpha)k^2 \int_\Omega u_N v 
  - N^2 \int_\Omega \frac{1}{r^2} u_N v = 0.
\end{align}

Using the Gauss-Divergence theorem, we may write the second term as an integral over the boundary of the domain, $\partial \Omega$,
\begin{align}
	\int_\Omega \nabla \cdot (v \nabla u ) = \int_{\partial\Omega} v \frac{\partial u_N}{\partial \vec{n}},
\end{align}
where $\vec{n}$ is the outward facing normal vector from the boundary, and
\begin{align}
	\frac{\partial u_N}{\partial \vec{n}} 
\end{align}
is the normal derivative.
The boundary integral may be further split up into parts sorted by their respective boundary conditions.
If the portion of the boundary whose solution value is known is represented by $\partial \Omega_D$ and the remaining boundary is represented as $\partial \Omega_N$, then
\begin{subequations}
\begin{align}
	\partial \Omega_D \cup \partial \Omega_N &= \partial \Omega. \\
	\partial \Omega_D \cap \partial \Omega_N &= \emptyset.
\end{align}
\end{subequations}
Given these exclusivity properties on the boundary, we may write the term for the boundary integral as
\begin{align}
	\int_{\partial\Omega} = \int_{\partial\Omega_D} + \int_{\partial\Omega_N}.
\end{align}
Since the test functions are exactly 0 on the Dirichlet portion of the boundary, it is the case that
\begin{align}
	\int_{\partial\Omega_D} v \frac{\partial u_N}{\partial \vec{n}} = 0.
\end{align}

Combining the results
\begin{align}
	\int_\Omega \nabla u_N \cdot \nabla v 
  - \int_{\partial\Omega_N} \nabla \cdot (v \nabla u ) 
  - (1+i\alpha)k^2 \int_\Omega u_N v 
  - N^2 \int_\Omega \frac{1}{r^2} u_N v = 0. \label{eqn:weakform}
\end{align}


One further point regarding the implementation of this within \oomph.
Complex numbers are not handled natively within \oomph.
Instead, a two-dimensional vector whose first and second components store the real and imaginary parts of a complex number, respectively.
Therefore to deal with this, we split the solution $u_N$ into its real and imaginary components.
If $u_r$ is the real part of the solution and $u_c$ is the imaginary part, then
\begin{align}
	u_N = u_r + i u_c.
\end{align}
Substituting this into \eqref{eqn:weakform} and separating real and imaginary parts is sufficient for the implementation.







% ----------------------------------------------------------

\section{Numerical integration}

The integrals involved in computing the solution are often too complicated evaluate analytically.
Instead, we use a numerical integration scheme to perform the integration.
Several methods exist to complete this task, but within \oomph, it is done using Gauss quadrature.

\cite{oomph}
Fix the dimension to be 2, so that we can talk specifics...
The Gauss rules are defined by following three quantities:
\begin{enumerate}
	\item the number of integration points, $N_\mathrm{int}$,
	\item the position of the integration points within an element, $S_i, \, i=1,2,\ldots,N_\mathrm{int}$,
	\item the integration weights, $W_i, \, i=1,2,\ldots,N_\mathrm{int}$.
\end{enumerate} 
Given these values, we can approximate an integral by summation of the integrand evaluated at the integration points multiplied by the corresponding integration weight.

We also must multiply by the Jacobian of the mapping from Cartesian to cylindrical coordinates.
Recall equation \eqref{eqn:cylindrical_mapping}, which states that the Jacobian of this transformation is $r$.
In addition, we have the transformation from global to local coordinates.
This mapping is given by some other function

Denote by $J$ the Jacobian of the mapping from global to local coordinates, then for an arbitrary element $E$, 
\begin{align}
	\iint_E f(r,z) r \,\d r \,\d z = \int_{-1}^1 \int_{-1}^1  f(s_1, s_2) J \, \d s_1 \, \d s_2 = \sum_{i=1}^{N_\mathrm{int}} f(S_{i,1},S_{i,2}) 
\end{align}






% ---------------------------------

\section{Refinement}

\iffalse
How are the meshes created?
What is the process of refinement?
	Adaptive vs uniform
Hanging nodes..
p-refinement: order of the elements
h-refinement: density/size of the mesh
Use this to generate the grids for Multigrid
\fi

There are several variations of refinement that can improve the accuracy of the finite element solution.
In addition to gains in solution accuracy, refinement is the method that we will generate the grid hierarchy for multigrid.
This is done by performing multiple refinements to achieve the finest level of refinement, then unrefining to obtain each coarse level.
More discussion of the grids used in multigrid is in chapter \ref{sec:mg}; here we will discuss the specific use of refinement within the FEM.
The largest scale of the solution can be at most at the scale of the mesh, so often refinement is necessary to resolve the exact features of the solution.
Each method of refinement comes with costs and benefits, as well as different complexities in implementation.

% Uniform refinement
The simplest case is uniform h-refinement.
In h-refinement, elements are subdivided into multiple new elements, reducing the element width and increasing the resolution of the mesh.
In uniform refinement, the entire mesh is refined by subdividing every element.
This increases the storage and computational cost of the method, but leads to a reduction in the solution error.
Figure \ref{fig:uniform} shows an example of a mesh consisting of four elements on the left and the result on the right after the application of uniform h-refinement.
We can see here that each element has been split into four new elements, each with element width half of the original element.

% Adaptive refinement
Beyond uniform refinement is adaptive refinement.
In certain cases where parts of the solution domain are singular or
In problems such as those involving boundary layers, for example in fluid dynamics, the solution may be highly varying in only one specific region.
By using an error estimator, it is possible to determine the areas of the mesh that require refinement.
Using uniform refinement on this problem, the grid size of the mesh will be reduced across the whole mesh, increasing computational cost.
Adaptive refinement has the benefit that computation is not wasted on computing the solution in regions where a sufficiently large mesh size is more appropriate.

However, adaptive refinement can introduce hanging nodes to the mesh.
Hanging nodes occur when a node is not shared between surrounding elements.
The problem with this type of node is that inter-element continuity of the solution is lost.
To overcome hanging nodes, we must impose constraints on the nodal values so that continuity between elements is maintained.
We will focus only on uniform refinement in this project and not discuss further adaptive refinement.

Figure \ref{fig:adaptive} shows an example of a mesh consisting of four elements on the left and the result on the right after the application of adaptive h-refinement.
On the right mesh, the element in the top right corner has been refined, while the others remain the same.
This has introduced two hanging nodes to the element, displayed here in red.

Alternatively, there is also p-refinement.
This method of refinement increases the order of the element by increasing the number of nodes.
Recall that we can find an interpolating polynomial that passes through $n+1$ distinct points with a polynomial of degree $n$.
So for example, if there are two nodes in a one-dimensional slice of an element, a linear polynomial can interpolate the solution between them.
If the solution is highly nonlinear, increasing the order of the interpolating polynomial will decrease the interpolation error.
Hence, increasing the number of nodes can lead to a reduction in the solution error.

\begin{figure}[h]
	% Uniform and adaptive refinement

	\centering
	
	\subfloat[][\label{fig:uniform} Uniform refinement of a mesh.]{\scalebox{0.4}{
		\begin{tikzpicture}[baseline,decoration={markings,mark=at position 1 with
			{\arrow[scale=5,>=stealth]{>}}}]
		\centering
		\begin{scope}
		
		% define constants
		\def \w {8}
		\def \d {4}
		
		% Draw the grids
		\draw[step=4,black,very thin] (0,0) grid (\w,\w);
		\draw[postaction={decorate}] (\w+1,\w/2) -- (\w+\d-1,\w/2);

		\draw[step=2,black,very thin] (\w+\d,0) grid (2*\w+\d,8);
		
		\end{scope}
		\end{tikzpicture}
	}}\\

	\subfloat[][\label{fig:adaptive} Adaptive refinement of a mesh; hanging nodes are displayed in red.]{\scalebox{0.4}{
		\begin{tikzpicture}[baseline,decoration={markings,mark=at position 1 with
			{\arrow[scale=5,>=stealth]{>}}}]
		\centering
		\begin{scope}
		
		% define constants
		\def \w {8}
		\def \d {4}
		
		% Draw the grids
		\draw[step=4,black,very thin] (0,0) grid (\w,\w);
		\draw[postaction={decorate}] (\w+1,\w/2) -- (\w+\d-1,\w/2);


		\draw[step=4,black,very thin] (\w+\d,0) grid (2*\w+\d,\w);
		\draw[step=2,black,very thin] (1.5*\w+\d,\w/2) grid (2*\w+\d,\w);

		\node [red,scale=2] at (1.5*\w+\d,0.75*\w) {\textbullet};
		\node [red,scale=2] at (1.75*\w+\d,0.5*\w) {\textbullet};
		
		\end{scope}
		\end{tikzpicture}
	}}

	\caption{\label{fig:refinement} An example of uniform and adaptive h-refinement on a mesh.}
\end{figure}







% ---------------------------------

\section{Computing the finite element solution}

Put it all together
Solve the full system
Solve the Jacobian, blah...

Newton's method is the general purpose solver for \oomph.
Our problem is linear, Newton solves it in one shot.

