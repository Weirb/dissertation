\chapter{The finite element method}
\label{sec:fem}

This chapter discusses the well known and widely used method for solving partial differential equations, the finite element method (FEM).
To avoid building and adding another library to the already vast ecosystem of available FEM software, we use the multi-physics FEM library, \oomph.
From the website, \oomph is:
\begin{quote}
	an object-oriented, open-source finite-element library for the simulation of multi-physics problems. \cite{oomph}
\end{quote}
There are several high level features of any general finite element procedure that will be addressed below.
Discussing these features in generality allows 
In addition to this, an overview of specific implementation details and features available in \oomph will also be covered.




% -----------------------------------------------------------

\section{Preliminaries}

We begin this chapter by discussing the necessary mathematical background for the finite element method.

Let us first define a problem in our context of interest.
A problem $(P)$ is one or more differential equations, together with appropriate boundary or initial conditions such that 

\iffalse WHAT DO WE NEED TO INCLUDE?

* Sobolev spaces
* Hilbert spaces 
* Banach spaces
* Norms/inner products

\fi



\subsection{Function spaces}
The test functions used in the upcoming weak formulation are members of a Sobolev space.
These function spaces are used to weight the residual of equation, 

The space of functions
\begin{align}
	H^1(\Omega) = \left\{ v | v \in L^2(\Omega), \, \nabla v \in (L^2(\Omega))^n \right\},
\end{align}
consists of those functions that are square-integrable and have a square-integrable derivative.



% -----------------------------------------------------------

\section{Nodes, elements, and meshes}

The main components of a finite element procedure are the nodes, the elements, and the mesh.
A mesh is a collection of elements; an element is a collection of nodes.

Each node contains data about its location within 

The elements are the 

What is the order of the element?

How do we get from global to local coordinates?
We need the mapping
And with that we need the Jacobian of the mapping
(we have two change of coordinates: Cartesian -> Cylindrical -> Local
And so we have two Jacobian mappings)

On the elements we have defined basis functions.
These represent the function 

Together with the elements, other fundamental pieces of the FEM are the nodes and the mesh.
Every element consists of multiple nodal points, each of which holds data required for solving the problem.
For example, nodes contain the global coordinate of their position within the mesh

A mesh is a collection of elements


There is one more detail of the hierarchy of entities for \oomph.
A \texttt{Problem} object contains details of a specific implementation for a problem, one of whose components is a mesh.
A \texttt{Node} objects contains multiple \texttt{Data} objects, holding the any or more of the data mentioned above.
This is simply an implementation detail, but an important one nonetheless. 


One of the fortunate things about the FEM is the discrete entities that are involved.
This lends itself to object-oriented programming (OOP) design principles particularly well.
Such a design strategy involves the definition of classes, and their instantiation as objects.
Furthermore, classes may be extended using inheritance, allowing for highly abstracted and generic classes, and on the other end, highly specific classes.
This works to both developers and users of the library advantage.
Developers are able to work independently of each other, knowing only how their respective objects should interact.
Users are able to extend previous work to suit their own needs.
Further discussion of OOP design principles is irrelevant and outside of the scope of this project.





\subsection{The Galerkin method}

In the Galerkin method, the test functions are the element basis functions.





% -----------------------------------------------------------

\section{Weak formulation}

The classical or strong formulation of a differential equation is a solution $u_N$ satisfying the PDE and boundary condition at every point in the domain.


The weak form of a differential equation is a relaxation of the conditions for the existence of a solution to the differential equation.

A weak solution $u_N$ satisfies the essential (Dirichlet) boundary condition and that the weighted residual vanishes for any test function that is 0 on the essential boundary.

Instead, upon multiplying by a test function and integrating over the domain, we instead require that the equation is satisfied for all test functions from an appropriate space of test functions.


A sufficiently smooth solution satisfying the weak form will also satisfies the stong form.
Therefore the two statements of the problem are equivalent, given the smoothness requirements of the classical formulation.


Given a test function $v$ from some function space $V$, we multiply our equation by $v$ and integrate over the domain.

The smoothness requirements for the strong form 



We will now derive the weak form of the CSLP equation, \eqref{eqn:cslp}.
Our first step is to multiply by a test function $v\in V$ and integrate over the domain $\Omega$.
\begin{align}
	-\int_\Omega \left(\nabla^2 u_N + \left[ (1+i\alpha)k^2-\frac{N^2}{r^2}\right]u_N \right) v = 0.
\end{align}
Using the property of the gradient operator,
\begin{align}
	\nabla \cdot ( v \nabla u) = v \nabla^2 u + \nabla u \cdot \nabla v,
\end{align}
we arrive at
\begin{align}
	\int_\Omega \nabla u_N \cdot \nabla v 
  - \int_\Omega \nabla \cdot (v \nabla u ) 
  - (1+i\alpha)k^2 \int_\Omega u_N v 
  - N^2 \int_\Omega \frac{1}{r^2} u_N v = 0.
\end{align}

Using the Gauss-Divergence theorem, we may write the second term as an integral over the boundary of the domain, $\partial \Omega$,
\begin{align}
	\int_\Omega \nabla \cdot (v \nabla u ) = \int_{\partial\Omega} v \frac{\partial u_N}{\partial \vec{n}},
\end{align}
where $\vec{n}$ is the outward facing normal vector from the boundary, and
\begin{align}
	\frac{\partial u_N}{\partial \vec{n}} 
\end{align}
is the normal derivative.
The boundary integral may be further split up into parts sorted by their respective boundary conditions.
If the portion of the boundary whose solution value is known is represented by $\partial \Omega_D$ and the remaining boundary is represented as $\partial \Omega_N$, then
\begin{subequations}
\begin{align}
	\partial \Omega_D \cup \partial \Omega_N &= \partial \Omega. \\
	\partial \Omega_D \cap \partial \Omega_N &= \emptyset.
\end{align}
\end{subequations}
Given these exclusivity properties on the boundary, we may write the term for the boundary integral as
\begin{align}
	\int_{\partial\Omega} = \int_{\partial\Omega_D} + \int_{\partial\Omega_N}.
\end{align}
Since the test functions are exactly 0 on the Dirichlet portion of the boundary, it is the case that
\begin{align}
	\int_{\partial\Omega_D} v \frac{\partial u_N}{\partial \vec{n}} = 0.
\end{align}

Combining the results
\begin{align}
	\int_\Omega \nabla u_N \cdot \nabla v 
  - \int_{\partial\Omega_N} \nabla \cdot (v \nabla u ) 
  - (1+i\alpha)k^2 \int_\Omega u_N v 
  - N^2 \int_\Omega \frac{1}{r^2} u_N v = 0. \label{eqn:weakform}
\end{align}


One further point regarding the implementation of this within \oomph.
Complex numbers are not handled natively within \oomph.
Instead, a two-dimensional vector whose first and second components store the real and imaginary parts of a complex number, respectively.
Therefore to deal with this, we split the solution $u_N$ into its real and imaginary components.
If $u_r$ is the real part of the solution and $u_c$ is the imaginary part, then
\begin{align}
	u_N = u_r + i u_c.
\end{align}
Substituting this into \eqref{eqn:weakform} and separating real and imaginary parts is sufficient for the implementation.







% ----------------------------------------------------------

\section{Numerical integration}

The integrals involved in computing the solution are often too complicated evaluate analytically.
Instead, we use a numerical integration scheme to perform the integration.
Several methods exist to complete this task, but within \oomph, it is done using Gauss quadrature.

\cite{oomph}
Fix the dimension to be 2, so that we can talk specifics...
The Gauss rules are defined by following three quantities:
\begin{enumerate}
	\item the number of integration points, $N_\mathrm{int}$,
	\item the position of the integration points within an element, $S_i, \, i=1,2,\ldots,N_\mathrm{int}$,
	\item the integration weights, $W_i, \, i=1,2,\ldots,N_\mathrm{int}$.
\end{enumerate} 
Given these values, we can approximate an integral by summation of the integrand evaluated at the integration points multiplied by the corresponding integration weight.

We also must multiply by the Jacobian of the mapping from Cartesian to cylindrical coordinates.
Recall equation \eqref{eqn:cylindrical_mapping}, which states that the Jacobian of this transformation is $r$.
In addition, we have the transformation from global to local coordinates.
This mapping is given by some other function

Denote by $J$ the Jacobian of the mapping from global to local coordinates, then for an arbitrary element $E$, 
\begin{align}
	\iint_E f(r,z) r \,\d r \,\d z = \int_{-1}^1 \int_{-1}^1  f(s_1, s_2) J \, \d s_1 \, \d s_2 = \sum_{i=1}^{N_\mathrm{int}} f(S_{i,1},S_{i,2}) 
\end{align}






% ---------------------------------

\section{Refinement}

How are the meshes created?
What is the process of refinement?
	Adaptive vs uniform
Hanging nodes..
p-refinement: order of the elements
h-refinement: density/size of the mesh
Use this to generate the grids for Multigrid









% ---------------------------------

\section{Computing the finite element solution}

Put it all together
Solve the full system
Solve the Jacobian, blah...

Newton's method is the general purpose solver for \oomph.
Our problem is linear, Newton solves it in one shot.

